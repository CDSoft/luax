#!/usr/bin/env -S luax --
local libs = {}
table.insert(package.searchers, 2, function(name) return libs[name] end)
local function lib(path, src) return assert(load(src, '@$ypp:'..path)) end
libs["atexit"] = lib("src/atexit.lua", [=[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `atexit(func)`: execute `func` when the whole output is computed, before actually writing the output.
@@@]]

local F = require "F"

local _functions = F{}

return setmetatable({}, {
    __call = function(_, func)
        _functions[#_functions+1] = func
    end,
    __index = {
        run = function(_)
            while #_functions > 0 do
                local fs = _functions
                _functions = F{}
                fs:foreach(F.call)
            end
        end,
    },
})
]=])
libs["comment"] = lib("src/comment.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `comment(...)`: returns an empty string (useful for commenting some text)

E.g.:

@q[=====[
```
@comment [===[
This paragraph is a comment
and is not part of the output document.
]===]
```
]=====]
@@@]]

local F = require "F"

return F.const ""
]======])
libs["convert"] = lib("src/convert.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

local flex = require "flex"

--[[@@@
* `convert(s, [opts])`:
  convert the string `s` from the format `opts.from` to the format `opts.to` and shifts the header levels by `opts.shift`.

This function requires a Pandoc Lua interpreter. The conversion is made by [Pandoc] itself.

The `opts` parameter is optional.
By default Pandoc converts documents from and to Markdown and the header level is not modified.

@q[=====[
The `convert` macro can also be called as a curried function (arguments can be swapped). E.g.:

    @convert {from="csv"} (script.python [===[
    # python script that produces a CSV document
    ]===])

Notice that `convert` can be implicitely called by `include` or `script` by giving the appropriate options. E.g.:

    @script.python {from="csv"} [===[
    # python script that produces a CSV document
    ]===]

]=====]
@@@]]

local convert = flex.str(function(content, opts)
    if not pandoc then
        ypp.error "the convert macro requires a Pandoc Lua interpreter"
    end
    opts = opts or {}
    local doc = pandoc.read(tostring(content), opts.from)
    local div = pandoc.Div(doc.blocks)
    if opts.shift then
        div = pandoc.walk_block(div, {
            Header = function(h)
                h = h:clone()
                h.level = h.level + opts.shift
                return h
            end,
        })
    end
    return pandoc.write(pandoc.Pandoc(div.content), opts.to)
end)

local convert_if_required = function(content, opts)
    opts = opts or {}
    content = tostring(content)
    if opts.from or opts.to or opts.shift then
        content = tostring(convert(content)(opts))
    end
    return content
end

return setmetatable({}, {
    __call = function(_, ...) return convert(...) end,
    __index = {
        if_required = convert_if_required
    },
})
]======])
libs["defer"] = lib("src/defer.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `defer(func)`: emit a unique tag that will later be replaced by the result of `func()`.

E.g.:

@q[=====[
```
@@ N = 0
total = @defer(function() return N end) (should be "2")
...
@@(N = N+1)
@@(N = N+1)
```
]=====]
@@@]]

local deferred_functions = {}

local function defer(func)
    local tag = string.format("▶%d◀", F.size(deferred_functions))
    deferred_functions[tag] = func
    return tag
end

local function replace(s)
    for tag, func in pairs(deferred_functions) do
        s = s:gsub(tag, func())
    end
    return s
end

return setmetatable({
    defer = defer,
    replace = replace,
}, {
    __call = function(self, s) return self.defer(s) end,
})
]======])
libs["doc"] = lib("src/doc.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

local F = require "F"
local flex = require "flex"
local convert = require "convert"

--[[@@@
* `doc(filename, [opts])`: extract documentation fragments from the file `filename` (all fragments are concatenated).

    - `opts.pattern` is the Lua pattern used to identify the documentation fragments. The default pattern is `@("@".."@@(.-)@@".."@")`.
    - `opts.from` is the format of the documentation fragments (e.g. `"markdown"`, `"rst"`, ...). The default format is Markdown.
    - `opts.to` is the destination format of the documentation (e.g. `"markdown"`, `"rst"`, ...). The default format is Markdown.
    - `opts.shift` is the offset applied to the header levels. The default offset is `0`.

@q[=====[
The `doc` macro can also be called as a curried function (arguments can be swapped). E.g.:

    @doc "file.c" {pattern="///(.-)///"}

]=====]
@@@]]

local function default_pattern()
    local tag = ("@"):rep(3)
    return tag.."(.-)"..tag
end

return flex.str(function(filename, opts)
    opts = opts or {}
    local pattern = opts.pattern or default_pattern()
    local content = ypp.with_inputfile(filename, function(full_filepath)
        local s = ypp.read_file(full_filepath)
        local output = F{}
        s:gsub(pattern, function(doc)
            output[#output+1] = ypp(doc)
        end)
        return output:unlines()
    end)
    content = convert.if_required(content, opts)
    return content
end)
]======])
libs["file"] = lib("src/file.lua", [=[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `f = file(name)`: return a file object that can be used to create files incrementally.
  Files are only saved once ypp succeed
* `f(s)`: add `s` to the file
* `f:ypp(s)`: preprocess and add `s` to the file
@@@]]

local F = require "F"

local file = {}
local file_mt = {__index={}}
local file_object_mt = {__index={}}

local outputs = F{}
file_mt.__index.outputs = outputs

local files = F{}
file_mt.__index.files = files

function file_mt:__call(name)
    outputs[#outputs+1] = name
    local f = setmetatable(F{name=name}, file_object_mt)
    files[#files+1] = f
    return f
end

function file_object_mt:__call(...)
    self[#self+1] = F.flatten{...}
end

function file_object_mt.__index:ypp(...)
    self[#self+1] = F.flatten{...}:map(ypp)
end

function file_object_mt.__index:flush()
    fs.mkdirs(self.name:dirname())
    fs.write(self.name, F.flatten(self):str())
end

return setmetatable(file, file_mt)
]=])
libs["flex"] = lib("src/flex.lua", [=[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LIB

local F = require "F"

-- A flex function is a curried function with a variable number of parameters.
-- It is implemented with a callable table.
-- The actual value is computed when evaluated as a string.
-- It takes several arguments:
--      - exactly one string (the argument)
--      - zero or many option tables (they are all merged until tostring is called)

-- e.g.:
--      function f(s, opt)
--          ...
--      end
--
--      g = flex(f)
--
--      g "foo" {x=1}       => calls f("foo", {x=1})
--      g {y=2} "foo" {x=1} => calls f("foo", {x=1, y=2})
--
--      h = g{z=3} -- kind of "partial application"
--
--      h "foo"             => calls f("foo", {z=3})
--      h "foo" {x=1}       => calls f("foo", {x=1, z=3})

local flex_str_mt = {}

function flex_str_mt:__call(x)
    local xmt = getmetatable(x)
    if type(x) ~= "table" or (xmt and xmt.__tostring) then
        -- called with a string or a table with a __tostring metamethod
        -- ==> store the string
        if self.s ~= F.Nil then ypp.error "multiple argument" end
        return setmetatable({s=tostring(x), opt=self.opt, f=self.f}, flex_str_mt)
    else
        -- called with an option table
        -- ==> add the new options to the current ones
        return setmetatable({s=self.s, opt=self.opt:patch(x), f=self.f}, flex_str_mt)
    end
end

function flex_str_mt:__tostring()
    -- string value requested
    -- convert to string and call f on this string
    if self.s == F.Nil then ypp.error "missing argument" end
    return tostring(self.f(tostring(self.s), self.opt))
end

function flex_str_mt:__index(k)
    -- string method requested but the object is not a string yet
    -- ==> make a string proxy
    if string[k] then
        return function(s, ...)
            return string[k](tostring(s), ...)
        end
    end
end

local function flex_str(f)
    return setmetatable({s=F.Nil, opt=F{}, f=f}, flex_str_mt)
end

-- flex_array is similar to flex_str but cumulates any number of parameters in an array

local flex_array_mt = {}

function flex_array_mt:__call(x)
    local xmt = getmetatable(x)
    if type(x) ~= "table" or (xmt and xmt.__tostring) then
        -- called with a string or a table with a __tostring metamethod
        -- ==> store the string
        return setmetatable({xs=self.xs..{x}, opt=self.opt, f=self.f}, flex_array_mt)
    else
        -- called with an option table
        -- ==> add the new options to the current ones
        return setmetatable({xs=self.xs, opt=self.opt:patch(x), f=self.f}, flex_array_mt)
    end
end

function flex_array_mt:__tostring()
    -- string value requested
    -- convert the result of f to a string
    return tostring(f(self.xs, self.opt))
end

local function flex_array(f)
    return setmetatable({xs=F{}, opt=F{}, f=f}, flex_array_mt)
end

return {
    str = flex_str,
    array = flex_array,
}
]=])
libs["image"] = lib("src/image.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `image(render, ext)(source)`: use the command `render` to produce an image from the source `source` with the format `ext` (`"svg"`, `"png"` or `"pdf"`).
  `image` returns the name of the image (e.g. to point to the image once deployed) and the actual file path (e.g. to embed the image in the final document).

The `render` parameter is a string that defines the command to execute to generate the image.
It contains some parameters:

- `%i` is replaced by the name of the input document (temporary file containing `source`).
- `%o` is replaced by the name of the output image file (generated from a hash of `source`).

Images are generated in a directory given by:

- the directory name given by the `--img` option
- the environment variable `YPP_IMG` if it is defined
- the directory name of the output file if the `-o` option is given
- the `img` directory in the current directory

If `source` starts with a `@` (e.g. `@q'"@filename"'`) then the actual image source is read from the file `filename`.

The image link in the output document may have to be different than the
actual path in the file system. This happens when the documents are not
generated in the same path than the source document. Brackets can be used to
specify the part of the path that belongs to the generated image but not to the
link in the output document in `YPP_IMG`.
E.g. if `YPP_IMG=[prefix]path` then images will be generated in `prefix/path`
and the link used in the output document will be `path`.

The file format (extension) must be in `render`, after the `%o` tag (e.g.: `%o.png`).

To avoid useless regenerations, a `.meta` file is created in the same directory than the image.
This file contains image information (source of the image, ypp parameters...).
The image is regenerated only if this information changes.
The `--meta` option can be used to save meta files in a different directory.

If the program requires a specific input file extension, it can be specified in `render`,
after the `%i` tag (e.g.: `%i.xyz`).

Some render commands are predefined.
For each render `X` (which produces images in the default format)
there are 3 other render commands `X.svg`, `X.png` and `X.pdf` which explicitely specify the image format.
They can be used similaryly to `image`: `X(source)`.

An optional table can be given before `source` to set some options:

* `X {name="output_name"} (source)` renders `source` and save the image to a file named `output_name`.
  This can help distributing documents with user friendly image names.

* `X {pp=func} (source)` renders `func(source)` instead of `source`.
  E.g.: if `func` is `ypp` then `source` is preprocessed by `ypp` before being rendered.

@@[===[
    local engine = {
        circo = "Graphviz",
        dot = "Graphviz",
        fdp = "Graphviz",
        neato = "Graphviz",
        osage = "Graphviz",
        patchwork = "Graphviz",
        sfdp = "Graphviz",
        twopi = "Graphviz",
        actdiag = "Blockdiag",
        blockdiag = "Blockdiag",
        nwdiag = "Blockdiag",
        packetdiag = "Blockdiag",
        rackdiag = "Blockdiag",
        seqdiag = "Blockdiag",
        mmdc = "Mermaid",
        asy = "Asymptote",
        plantuml = "PlantUML",
        ditaa = "ditaa",
        gnuplot = "gnuplot",
        lsvg = "lsvg",
        octave = "octave",
    }
    local function cmp(x, y)
        assert(engine[x], x.." engine unknown")
        assert(engine[y], y.." engine unknown")
        if engine[x] == engine[y] then return x < y end
        return engine[x] < engine[y]
    end
    return F{
        "Image engine | ypp function | Example",
        "-------------|--------------|--------",
    }
    ..
    F.keys(image):sort(cmp):map(function(x)
        return ("[%s] | `%s` | `image.%s(source)`"):format(engine[x], x, x)
    end)
]===]

Example:

@q[=====[
``` markdown
![ypp image generation example](@image.dot [===[
digraph {
    rankdir=LR;
    input -> ypp -> output
    ypp -> image
}
]===])
```
]=====]

is rendered as

![ypp image generation example](@image.dot {name="image"} [===[
digraph {
    rankdir=LR;
    input -> ypp -> output
    ypp -> image
}
]===])

@@@]]

local F = require "F"
local fs = require "fs"
local sh = require "sh"

local output_path   -- actual directory where images are saved
local link_path     -- directory added to image filenames
local img_path      -- default path for generated images
local meta_path     -- default path for meta image files

local function parse_output_path(path)
    local prefix, link = path : match "^%[(.-)%](.*)"
    if prefix then
        output_path = fs.join(prefix, link)
        link_path = link
    else
        output_path = path
        link_path = path
    end
end

local function get_input_ext(s)
    return s:match("%%i(%.%w+)") or ""
end

local function get_ext(s, t)
    return s:match("%%o(%.%w+)") or t:match("%%o(%.%w+)") or ""
end

local function make_diagram_cmd(src, out, render)
    return render:gsub("%%i", src):gsub("%%o", out)
end

local function render_diagram(cmd)
    if cmd:match "^asy " then
        -- for asymptote, the -o option is the output name without its extension
        cmd = cmd:gsub("(-o )(%S+)", function(opt, name)
            return opt..name:splitext()
        end)
    end
    -- stdout shall be discarded otherwise ypp can not be used in a pipe
    if not sh.read(cmd) then ypp.error "diagram error" end
end

local output_file -- filename given by the -o option

local function default_image_output()
    if not output_path then
        local env = os.getenv "YPP_IMG"
        parse_output_path(
            img_path
            or (env and env ~= "" and env)
            or (output_file and fs.join(fs.dirname(output_file), "img"))
            or "img")
    end
end

local function diagram(exe, render, default_ext)
    local template
    if type(render) == "table" then
        render, template = F.unpack(render)
    else
        template = "%s"
    end
    render = render
        : gsub("%%exe", exe or "%0")
        : gsub("%%ext", default_ext or "%0")
        : gsub("%%o", default_ext and ("%%o."..default_ext) or "%0")
    template = template
        : gsub("%%ext", default_ext or "%0")
        : gsub("%%o", default_ext and ("%%o."..default_ext) or "%0")
    render = F.I{ext=default_ext}(render)
    local render_image = function(contents, opts)
        local filename = contents:match("^@([^\n\r]+)$")
        if filename then
            contents = tostring(include.raw(filename))
        end
        contents = (opts.pp or F.id)(contents)
        local input_ext = get_input_ext(render)
        local ext = get_ext(render, template)
        local hash = crypt.hash(render..contents)
        default_image_output()
        fs.mkdirs(output_path)
        local img_name = opts.name or hash
        local out = fs.join(output_path, img_name)
        local link = fs.join(link_path, fs.basename(out))
        local meta = (meta_path and meta_path/img_name or out)..ext..".meta"
        local meta_content = F.unlines {
            "hash: "..hash,
            "render: "..render,
            "out: "..out,
            "link: "..link,
            "",
            (template : gsub("%%s", contents)),
        }
        local old_meta = fs.read(meta) or ""
        if not fs.is_file(out..ext) or meta_content ~= old_meta then
            fs.with_tmpdir(function(tmpdir)
                fs.mkdirs(fs.dirname(out))
                local name = fs.join(tmpdir, "diagram")
                local name_ext = name..input_ext
                local templated_contents = template
                    : gsub("%%o", out)
                    : gsub("%%s", contents)
                if not fs.write(name_ext, templated_contents) then ypp.error("can not create %s", name_ext) end
                if not fs.write(meta, meta_content) then ypp.error("can not create %s", meta) end
                local render_cmd = make_diagram_cmd(name, out, render)
                render_diagram(render_cmd)
            end)
        end
        return link..ext, out..ext
    end
    return function(param)
        if type(param) == "table" then
            local opts = param
            return function(contents)
                return render_image(contents, opts)
            end
        else
            local contents = param
            return render_image(contents, {})
        end
    end
end

local default_ext = "svg"

local PLANTUML = _G["PLANTUML"] or os.getenv "PLANTUML" or fs.join(fs.dirname(arg[0]), "plantuml.jar")
local DITAA = _G["DITAA"] or os.getenv "DITAA" or fs.join(fs.dirname(arg[0]), "ditaa.jar")

local graphviz = "%exe -T%ext -o %o %i"
local plantuml = "java -jar "..PLANTUML.." -pipe -charset UTF-8 -t%ext < %i > %o"
local asymptote = "%exe -f %ext -o %o %i"
local mermaid = "%exe --pdfFit -i %i -o %o"
local blockdiag = "%exe -a -T%ext -o %o %i"
local ditaa = "java -jar "..DITAA.." $(ext=='svg' and '--svg' or '') -o -e UTF-8 %i %o"
local gnuplot = "%exe -e 'set terminal %ext' -e 'set output \"%o\"' -c %i"
local lsvg = "%exe %i.lua -o %o"
local octave = { "octave --no-gui %i", 'figure("visible", "off")\n\n%s\nprint %o;' }

local function define(t)
    local self = {}
    local mt = {}
    for k, v in pairs(t) do
        if k:match "^__" then
            mt[k] = v
        else
            self[k] = v
        end
    end
    return setmetatable(self, mt)
end

local function instantiate(exe, render)
    return define {
        __call = function(_, ...) return diagram(exe, render, default_ext)(...) end,
        svg = diagram(exe, render, "svg"),
        png = diagram(exe, render, "png"),
        pdf = diagram(exe, render, "pdf"),
    }
end

return define {
    dot         = instantiate("dot", graphviz),
    neato       = instantiate("neato", graphviz),
    twopi       = instantiate("twopi", graphviz),
    circo       = instantiate("circo", graphviz),
    fdp         = instantiate("fdp", graphviz),
    sfdp        = instantiate("sfdp", graphviz),
    patchwork   = instantiate("patchwork", graphviz),
    osage       = instantiate("osage", graphviz),
    plantuml    = instantiate("plantuml", plantuml),
    asy         = instantiate("asy", asymptote),
    mmdc        = instantiate("mmdc", mermaid),
    actdiag     = instantiate("actdiag", blockdiag),
    blockdiag   = instantiate("blockdiag", blockdiag),
    nwdiag      = instantiate("nwdiag", blockdiag),
    packetdiag  = instantiate("packetdiag", blockdiag),
    rackdiag    = instantiate("rackdiag", blockdiag),
    seqdiag     = instantiate("seqdiag", blockdiag),
    ditaa       = instantiate("ditaa", ditaa),
    gnuplot     = instantiate("gnuplot", gnuplot),
    lsvg        = instantiate("lsvg", lsvg),
    octave      = instantiate("octave", octave),
    __call = function(_, render, ext) return diagram(nil, render, ext) end,
    __index = {
        format = function(fmt) default_ext = fmt end,
        output = function(path) output_file = path end,
        set_img_path = function(path) img_path = path end,
        set_meta_path = function(path) meta_path = path end,
    },
}
]======])
libs["include"] = lib("src/include.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

local F = require "F"

local flex = require "flex"
local convert = require "convert"

--[[@@@
* `include(filename, [opts])`: include the file `filename`.

    - `opts.pattern` is the Lua pattern used to identify the part of the file to include. If the pattern is not given, the whole file is included.
    - `opts.exclude` is the Lua pattern used to identify parts of the file to exclude. If the pattern is not given, the whole file is included.
    - `opts.from` is the format of the input file (e.g. `"markdown"`, `"rst"`, ...). The default format is Markdown.
    - `opts.to` is the destination format (e.g. `"markdown"`, `"rst"`, ...). The default format is Markdown.
    - `opts.shift` is the offset applied to the header levels. The default offset is `0`.

* `include.raw(filename, [opts])`: like `include` but the content of the file is not preprocessed with `ypp`.

@q[=====[
The `include` macro can also be called as a curried function (arguments can be swapped). E.g.:

    @include "file.csv" {from="csv"}
    @include {from="csv"} "file.csv"

]=====]
@@@]]

local function include(filename, opts, prepro)
    opts = opts or {}
    local content = ypp.with_inputfile(filename, function(full_filepath)
        local s = ypp.read_file(full_filepath)
        if opts.pattern then s = s:match(opts.pattern) end
        if opts.exclude then s = s:gsub(opts.exclude, "") end
        return ypp.lconf(prepro, s)
    end)
    content = convert.if_required(content, opts)
    return content
end

local flex_include     = flex.str(function(filename, opts) return include(filename, opts, ypp) end)
local flex_include_raw = flex.str(function(filename, opts) return include(filename, opts, F.id) end)

return setmetatable({
    raw = flex_include_raw,
}, {
    __call = function(_, ...) return flex_include(...) end,
})
]======])
libs["parser"] = lib("src/parser.lua", [===[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LIB

local F = require "F"

local function format_value(x)
    local mt = getmetatable(x)
    if mt and mt.__tostring then return tostring(x) end
    if type(x) == "table" then return F.map(tostring, x):unlines() end
    return tostring(x)
end

local function traceback(tag, expr, conf)
    if tag==conf.expr and expr:match("^[%w_.]*$") then return F.const() end
    return function(message, opts)
        if opts and opts.erroneous_source then
            -- Compilation error
            ypp.error_in(opts.erroneous_source, "%s", message)
        else
            -- Execution error => print the traceback
            ypp.error("%s", message)
        end
        os.exit(1)
    end
end

local function eval(s, tag, expr, state)
    local msgh = traceback(tag, expr, state.conf)
    local expr_tag = state.conf.expr -- must be read before eval since they may be modified by the macro function
    local stat_tag = state.conf.stat
    local ok_compile, chunk, compile_error = xpcall(load, msgh, (tag==expr_tag and "return " or "")..expr, expr, "t")
    if not ok_compile then return s end -- load execution error
    if not chunk then -- compilation error
        msgh(compile_error, {erroneous_source=expr})
        return s
    end
    local ok_eval, val = xpcall(chunk, msgh)
    if not ok_eval then return s end
    if val == nil and tag==expr_tag and expr:match("^[%w_]+$") then return s end
    if tag == stat_tag then
        if val ~= nil then
            return format_value(val)
        else
            return ""
        end
    end
    return format_value(val)
end

-- a parser is a function that takes a string and a position
-- and returns the start and stop of the next expression

local function empty(_, i0) return i0, i0 end

local function parse_token(skip)
    return function(x)
        local pattern = "^"..skip.."()"..x.."()"
        return function(s, i0)
            if not i0 then return end
            return s:match(pattern, i0)
        end
    end
end

local function seq2(p1, p2)
    return function(s, i0)
        local i1, i2 = p1(s, i0)
        local i3, i4 = p2(s, i2)
        if i3 then return i1, i4 end
    end
end

local function alt(ps)
    return function(s, i0)
        for _, p in ipairs(ps) do
            local i1, i2 = p(s, i0)
            if i1 then return i1, i2 end
        end
    end
end

local token         = parse_token "%s*"
local jump_to_token = parse_token ".-"

local parse_parentheses     = token "%b()" -- (...)
local parse_brackets        = token "%b{}" -- {...}
local parse_square_brackets = token "%b[]" -- [...]

local parse_long_string_open = token"%[=-%["
local parse_long_string_close = function(level) return jump_to_token("]"..level.."]") end

local function parse_long_string(s, i0)
    -- [==[ ... ]==]
    local o1, o2 = parse_long_string_open(s, i0)
    if not o1 then return end
    local c1, c2 = parse_long_string_close(s:sub(o1+1, o2-2))(s, o2)
    if c1 then return o1, c2 end
end

local function parse_quoted_string(c)
    local boundary = token(c)
    return function(s, i0)
        local i1, i2 = boundary(s, i0)
        if not i1 then return end
        local i = i2
        while i <= #s do
            local ci = s:sub(i, i)
            if ci == c then return i1, i+1 end
            if ci == '\\' then i = i + 1 end
            i = i + 1
        end
    end
end

local parse_single_quoted_string = parse_quoted_string "'"
local parse_double_quoted_string = parse_quoted_string '"'
local parse_ident = token"[%w_]+"
local parse_field_access = token"[.:]"
local parse_dot = token"%."
local parse_eq = token"="

local sexpr_parsers

local function parse_sexpr(s, i0)
    if not i0 then return end
    return alt(sexpr_parsers)(s, i0)
end

-- E -> ident SE
local parse_expr = seq2(parse_ident, parse_sexpr)

sexpr_parsers = {
    seq2(parse_parentheses, parse_sexpr),           -- SE -> (...) SE
    seq2(parse_brackets, parse_sexpr),              -- SE -> {...} SE
    seq2(parse_double_quoted_string, parse_sexpr),  -- SE -> "..." SE
    seq2(parse_single_quoted_string, parse_sexpr),  -- SE -> '...' SE
    seq2(parse_long_string, parse_sexpr),           -- SE -> [[...]] SE
    seq2(parse_square_brackets, parse_sexpr),       -- SE -> [...] SE
    seq2(parse_field_access, parse_expr),           -- SE -> [.:] E
    empty,                                          -- SE -> empty
}

local function parse_lhs(s, i0)
    -- LHS -> identifier ([...] | '.' identifier)*
    local i1, i2 = parse_ident(s, i0)
    if not i1 then return end
    local i = i2
    ::loop::
    local i3, i4 = parse_square_brackets(s, i)
    if i3 then i = i4; goto loop end
    local i5, i6 = parse_dot(s, i) ---@diagnostic disable-line: unused-local
    local i7, i8 = parse_ident(s, i6)
    if i7 then i = i8; goto loop end
    return i1, i
end

local rhs_parsers = {
    token"%-?%d+%.%d+e%-?%d+",          -- RHS -> number
    token"%-?%d+%.e%-?%d+",             -- RHS -> number
    token"%-?%.%d+e%-?%d+",             -- RHS -> number
    token"%-?%d+e%-?%d+",               -- RHS -> number
    token"%-?%d+%.%d+",                 -- RHS -> number
    token"%-?%d+%.",                    -- RHS -> number
    token"%-?%.%d+",                    -- RHS -> number
    token"%-?%d+",                      -- RHS -> number
    token"true",                        -- RHS -> boolean
    token"false",                       -- RHS -> boolean
    parse_parentheses,                  -- RHS -> (...)
    parse_brackets,                     -- RHS -> {...}
    parse_double_quoted_string,         -- RHS -> "..."
    parse_single_quoted_string,         -- RHS -> '..."
    parse_long_string,                  -- RHS -> [=[ ... ]=]
    parse_expr,                         -- RHS -> expr
}

local parse_rhs = alt(rhs_parsers)

local function parse(s, i0, state)

    local expr_tag = state.conf.expr
    local esc_expr_tag = state.conf.esc_expr
    local stat_tag = state.conf.stat

    local parse_tag = jump_to_token(esc_expr_tag.."+")

    -- find the start of the next expression
    local i1, i2 = parse_tag(s, i0)
    if not i1 then return #s+1, #s+1, "" end
    local tag = s:sub(i1, i2-1)

    -- S -> "@@ LHS = RHS
    if tag == stat_tag then
        local i3, i4 = parse_lhs(s, i2)
        local i5, i6 = parse_eq(s, i4) ---@diagnostic disable-line: unused-local
        local i7, i8 = parse_rhs(s, i6)
        if i7 then return i1, i8, eval(s:sub(i1, i8-1), tag, s:sub(i3, i8-1), state) end
    end

    -- S -> "(@|@@)..."
    if tag == expr_tag or tag == stat_tag then
        do -- S -> "(@|@@)(...)"
            local i3, i4 = parse_parentheses(s, i2)
            if i3 then return i1, i4, eval(s:sub(i1, i4-1), tag, s:sub(i3+1, i4-2), state) end
        end
        do -- S -> "(@|@@)[==[...]==]"
            local i3, i4 = parse_long_string(s, i2)
            if i3 then
                local expr = s:sub(i3, i4-1):gsub("^%[=*%[(.*)%]=*%]$", "%1")
                return i1, i4, eval(s:sub(i1, i4-1), tag, expr, state)
            end
        end
        do -- S -> "(@|@@)"expr
            local i3, i4 = parse_expr(s, i2)
            if i3 then return i1, i4, eval(s:sub(i1, i4-1), tag, s:sub(i3, i4-1), state) end
        end
    end

    -- S -> @+ (return the invalid tag unchanged)
    return i1, i2, tag

end

return function(s, conf)
    local ts = {}
    local state = {conf=conf}
    local i = 1
    while i <= #s do
        local i1, i2, out = parse(s, i, state)
        if not i2 then
            ts[#ts+1] = s:sub(i, #s)
            break
        end
        if i1 > i then ts[#ts+1] = s:sub(i, i1-1) end
        ts[#ts+1] = out
        i = i2
    end
    return table.concat(ts)
end
]===])
libs["q"] = lib("src/q.lua", [=[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `q(source)`: return `source` unpreprocessed.
  `q` is used to avoid macro execution in a portion of text.
@@@]]

local F = require "F"

return F.id
]=])
libs["script"] = lib("src/script.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `script(cmd)(source)`: execute `cmd` to interpret `source`.
  `source` is first saved to a temporary file which name is added to the command `cmd`.
  If `cmd` contains `%s` then `%s` is replaces by the temporary script name.
  Otherwise the script name is appended to the command.
  An explicit file extension can be given after `%s` for languages that require
  specific file extensions (e.g. `%s.fs` for F#).

`script` also predefines shortcuts for some popular languages:

@@( local descr = {
        bat = "`command` (DOS/Windows)",
        cmd = "`cmd` (DOS/Windows)",
        sh = "sh",
        bash = "bash",
        zsh = "zsh",
    }
    return F.keys(script):map(function(lang)
        return ("- `script.%s(source)`: run a script with %s"):format(lang, descr[lang] or lang:cap())
    end)
)

Example:

@q[=====[
```
$\sum_{i=0}^100 = @script.python "print(sum(range(101)))"$
```
]=====]
is rendered as
```
$\sum_{i=0}^100 = @script.python "print(sum(range(101)))"$
```
@@@]]

local fs = require "fs"
local sh = require "sh"
local flex = require "flex"
local convert = require "convert"

local function make_script_cmd(cmd, arg, ext)
    arg = arg..ext
    local n1, n2
    cmd, n1 = cmd:gsub("%%s"..(ext~="" and "%"..ext or ""), arg)
    cmd, n2 = cmd:gsub("%%s", arg)
    if n1+n2 == 0 then cmd = cmd .. " " .. arg end
    return cmd
end

local function script_ext(cmd)
    local ext = cmd:match("%%s(%.%w+)") -- extension given by the command line
    return ext or ""
end

local function run(cmd)
    return flex.str(function(content, opts)
        content = tostring(content)
        return fs.with_tmpdir(function (tmpdir)
            local name = fs.join(tmpdir, "script")
            local ext = script_ext(cmd)
            fs.write(name..ext, content)
            local output = sh.read(make_script_cmd(cmd, name, ext))
            if output then
                output = output:gsub("%s*$", "")
                output = convert.if_required(output, opts)
                return output
            else
                error("script error")
            end
        end)
    end)
end

return setmetatable({
    python = run "python %s.py",
    lua = run "lua %s.lua",
    bash = run "bash %s.sh",
    zsh = run "zsh %s.sh",
    sh = run "sh %s.sh",
    cmd = run "cmd %s.cmd",
    bat = run "command %s.bat",
}, {
    __call = function(_, cmd) return run(cmd) end,
})
]======])
libs["when"] = lib("src/when.lua", [======[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@LOAD

--[[@@@
* `when(cond)(text)`: emit `text` only if `cond` is true.

E.g.:

@q[=====[
```
@when(lang=="en")
[===[
The current language is English.
]===]
```
]=====]
@@@]]

local F = require "F"

return function(cond)
    return cond and ypp or F.const ""
end
]======])
libs["_YPP_VERSION"] = lib(".build/_YPP_VERSION", [=[return [[1.8.2]]]=])
_ENV["atexit"] = require "atexit"
_ENV["comment"] = require "comment"
_ENV["convert"] = require "convert"
_ENV["defer"] = require "defer"
_ENV["doc"] = require "doc"
_ENV["file"] = require "file"
_ENV["image"] = require "image"
_ENV["include"] = require "include"
_ENV["q"] = require "q"
_ENV["script"] = require "script"
_ENV["when"] = require "when"
return lib("src/ypp.lua", [=[--[[
This file is part of ypp.

ypp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ypp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ypp.  If not, see <https://www.gnu.org/licenses/>.

For further information about ypp you can visit
https://codeberg.org/cdsoft/ypp
--]]

--@MAIN

--[[@@@
* `ypp(s)`: apply the `ypp` preprocessor to a string.
* `ypp.input_file()`: return the name of the current input file.
* `ypp.input_path()`: return the path of the current input file.
* `ypp.input_file(n)`: return the name of the nth input file in the current *include* stack.
* `ypp.input_path(n)`: return the path of the nth input file in the current *include* stack.
* `ypp.output_file`: name of the output file.
* `ypp.find_file(filename)`: return the full path name of `filename` that can be in the current input file directory or in the current directory.
* `ypp.read_file(filename)`: return the content of the file `filename` and adds this file to the dependency file.
* `ypp.macro(c)`: use the character `c` to start Lua expressions instead of `"@"` (and `cc` instead of `"@@"`).
@@@]]

local F = require "F"
local fs = require "fs"
local term = require "term"

-- preload some LuaX modules
_G.F = F
_G.crypt = require "crypt"
_G.fs = fs
_G.sh = require "sh"
_G.sys = require "sys"
_G.import = require "import"

_G._YPP_VERSION = require "_YPP_VERSION"

local default_local_configuration = {
    expr = "@",     esc_expr = "@",
    stat = "@@",    esc_stat = "@@",
}

local lconf = setmetatable({}, {      -- stack of local configurations
    __index = {
        top = function(self) return self[#self] end,
    },
    __call = function(self, f, ...)
        self[#self+1] = F.clone(default_local_configuration)
        local val = f(...)
        self[#self] = nil
        return val
    end,
})

local ypp_mt = {
    __index={
        lconf = lconf,
    },
}
local ypp = {}
local known_input_files = F{}
local output_contents = F{}
local input_files = F{fs.join(fs.getcwd(), "-")} -- stack of input files (current branch from the root to the deepest included document)
local output_file = "-"

local red  = F.id   ---@type function | table
local cyan = F.id   ---@type function | table

local function colorize()
    red  = term.color.red
    cyan = term.color.cyan
end

if term.isatty(io.stderr) then colorize() end

local function print_frame(source, source_name, line)
    local context = 5
    io.stderr:write("\n", cyan(source_name..":"..line..":"), "\n")
    source = source or ""
    source : lines() : foreachi(function(i, l)
        if math.abs(i - line) > context then return end
        if i == line then
            io.stderr:write(red(("%4d => %s"):format(i, l)), "\n")
        else
            io.stderr:write(("%4d |  %s"):format(i, l), "\n")
        end
    end)
end

local function print_traceback()
    for level = 1, math.huge do
        local info = debug.getinfo(level)   if not info then break end
                                            if info.short_src:head() == "$" then goto next_frame end
                                            if info.short_src == "[C]"      then goto next_frame end
        local source = info.source:head()=="@" and fs.read(info.source:tail()) or info.source
        print_frame(source, info.short_src, info.currentline)
    ::next_frame::
    end
end

local function parse_error(msg, ...)
    msg = msg : format(...)
    local filename, err_line, err = msg : match "^(.-):(%d+):%s*(.*)$"
    return filename, tonumber(err_line), err or msg
end

local function print_error(filename, err_line, msg)
    if err_line then
        io.stderr:write(cyan(filename..":"..err_line..":"), " ", red"error:", " ", msg, "\n")
    else
        io.stderr:write(red"error:", " ", msg, "\n")
    end
end

function ypp_mt.__index.error(msg, ...)
    local filename, err_line, err = parse_error(msg, ...)
    print_error(filename, err_line, err)
    print_traceback()
    os.exit(1)
end

function ypp_mt.__index.error_in(source, msg, ...)
    local filename, err_line, err = parse_error(msg, ...)
    print_error(filename, err_line, err)
    print_frame(source, filename, err_line)
    os.exit(1)
end

local function load_script(script)
    script = script:gsub("%.lua$", "")
    local modname, filename = script:match "(.-)=(.+)"
    if not modname then
        modname, filename = script, script
    end
    local mod = require(filename)
    if modname ~= "_" then
        _G[modname] = mod
    end
end

local function eval_stat(stat)
    assert(load(stat, stat, "t"))()
end

local function eval_definition(def)
    local name, value = def : split("=", 1) : unpack()
    _G[name] = value or ""
end

local function add_path(paths)
    if not paths then return end
    local dir_sep, template_sep, template, _ = F(package.config):lines():unpack()
    package.path = F.concat {
        paths:split(template_sep):map(function(path) return path..dir_sep..template..".lua" end),
        { package.path }
    } : str(template_sep)
end

local function process(content)
    output_contents[#output_contents+1] = lconf(ypp, content)
end

local function read_file(filename)
    local content
    if filename == "-" then
        content = io.stdin:read "a"
    else
        content = fs.read(filename)
        if not content then ypp.error("%s: can not read file", filename) end
        known_input_files[#known_input_files+1] = filename:gsub("^"..fs.getcwd()..fs.sep, "")
    end
    return content
end

ypp.read_file = read_file

local function find_file(filename)
    local current_input_file = input_files:last()
    local input_path = fs.dirname(current_input_file)
    local full_filepath = F{
        fs.join(input_path, filename),
        filename,
    } : find(fs.is_file)
    if not full_filepath then ypp.error("%s: file not found", filename) end
    return full_filepath
end

ypp.find_file = find_file

local function with_inputfile(filename, func)
    if filename == "-" then return func(filename) end
    local full_filepath = find_file(filename)
    input_files[#input_files+1] = full_filepath
    local res = {func(full_filepath)}
    input_files[#input_files] = nil
    return F.unpack(res)
end

ypp.with_inputfile = with_inputfile

local function process_file(filename)
    return with_inputfile(filename, function(full_filepath)
        return process(read_file(full_filepath))
    end)
end

function ypp.input_file(level)
    return input_files[#input_files-(level or 0)]
end

function ypp.input_path(level)
    return fs.dirname(input_files[#input_files-(level or 0)])
end

function ypp.output_file()
    return output_file
end

local escaped_macro_char = {
    ["^"] = "%^",
    ["$"] = "%$",
    ["%"] = "%%",
    ["."] = "%.",
    ["*"] = "%*",
    ["+"] = "%+",
    ["-"] = "%-",
    ["?"] = "%?",
}

local forbidden_macro_char = {
    ["("] = true, [")"] = true,
    ["["] = true, ["]"] = true,
    ["{"] = true, ["}"] = true,
}

local function update_macro_char(funcname, conf, char)
    if type(char) ~= "string" or #char ~= 1 then
        ypp.error("%s expects a single character", funcname)
    end
    if forbidden_macro_char[char] then
        ypp.error("%q: invalid macro character", char)
    end
    conf.expr = char
    conf.stat = char..char
    local esc_char = escaped_macro_char[char] or char
    conf.esc_expr = esc_char
    conf.esc_stat = esc_char..esc_char
end

local function set_macro_char(funcname, char)
    update_macro_char(funcname, lconf:top(), char)
end

function ypp.macro(char)
    set_macro_char("ypp.macro", char)
    return ""
end

function ypp_mt.__call(_, content)
    if type(content) == "table" then return F.map(ypp, content) end
    local parser = require "parser"
    return parser(content, lconf:top())
end

local function write_outputs(args)
    local content = defer.replace(output_contents:str())
    if not args.output or args.output == "-" then
        io.stdout:write(content)
    else
        fs.mkdirs(fs.dirname(args.output))
        fs.write(args.output, content)
    end
    local file = require "file"
    file.files:foreach(function(f) f:flush() end)
end

local function write_dep_file(args)
    if not (args.gendep or args.depfile or #args.targets>0) then return end
    local name = args.depfile or (args.output and fs.splitext(args.output)..".d")
    if not name then ypp.error("the dependency file name is unknown, use --MF or -o") end
    local function mklist(...)
        return F{...}:flatten():nub()
            :filter(function(p) return p ~= "-" end)
            :map(function(p) return p:gsub("^%."..fs.sep, "") end)
            :unwords()
    end
    local scripts = F.values(package.modpath)
    local file = require "file"
    local deps = mklist(args.targets, args.output or {}, file.outputs).." : "..mklist(known_input_files, scripts)
    fs.mkdirs(fs.dirname(name))
    fs.write(name, deps.."\n")
end

local function parse_args()
    local parser = require "argparse"()
        : name "ypp"
        : description(("ypp %s\nYet a PreProcessor"):format(_YPP_VERSION))
        : epilog "For more information, see https://codeberg.org/cdsoft/ypp"

    parser : flag "-v"
        : description "Show ypp version"
        : action(function(_, _, _, _) print(_YPP_VERSION); os.exit() end)

    parser : flag "-a"
        : description "Force colorization using ANSI codes"
        : target "color"
        : action(function(_, _, _, _) colorize() end)

    parser : option "-l"
        : description "Execute a Lua script"
        : argname "script"
        : count "*"
        : action(function(_, _, script, _) load_script(script) end)

    parser : option "-e"
        : description "Execute a Lua statement"
        : argname "statement"
        : count "*"
        : action(function(_, _, stat, _) eval_stat(stat) end)

    parser : option "-D"
        : description "Define a Lua variable (-DNAME=\"string\")"
        : argname "definition"
        : count "*"
        : action(function(_, _, def, _) eval_definition(def) end)

    parser : option "-p"
        : description "Add a path to package.path"
        : argname "path"
        : count "*"
        : action(function(_, _, path, _) add_path(path) end)

    local output = nil
    parser : option "-o"
        : description "Redirect the output to 'file'"
        : target "output"
        : argname "file"
        : action(function(_, _, path, _)
            output = path
            output_file = path
            require"image".output(output)
        end)

    parser : option "-t"
        : description "Set the default format of generated images"
        : target "image_format"
        : choices { "svg", "pdf", "png" }
        : action(function(_, _, fmt, _) require"image".format(fmt) end)

    parser : option "--MT"
        : description "Add `target` to the target list (implies `--MD`)"
        : target "targets"
        : argname "target"
        : count "*"

    parser : option "--MF"
        : description "Set the dependency file name (implies `--MD`)"
        : target "depfile"
        : argname "name"

    parser : flag "--MD"
        : description "Generate a dependency file"
        : target "gendep"

    parser : option "--img"
        : description "Set the path for generated images"
        : target "imgpath"
        : argname "path"
        : action(function(_, _, path, _) require "image".set_img_path(path) end)

    parser : option "--meta"
        : description "Set the path for generated meta image files"
        : target "metapath"
        : argname "path"
        : action(function(_, _, path, _) require "image".set_meta_path(path) end)

    parser : option "-m"
        : description("Set the default macro character (default: '"..default_local_configuration.expr.."')")
        : target "macro_char"
        : argname "char"
        : action(function(_, _, c, _)
            update_macro_char("-m", default_local_configuration, c)
        end)

    parser : argument "input"
        : description "Input file"
        : args "*"
        : action(function(_, _, names, _)
            if #names == 0 then names = {"-"} end
            F.foreach(names, process_file)
        end)

    return F.patch(parser:parse(), {output=output})
end

_ENV.ypp = setmetatable(ypp, ypp_mt)
local args = parse_args()
require "atexit".run()
write_dep_file(args)
write_outputs(args)
]=])()

